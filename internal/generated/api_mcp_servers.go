/*
Corax API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.91.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// MCPServersAPIService MCPServersAPI service
type MCPServersAPIService service

type MCPServersAPICheckMcpServerHealthV1McpServersServerIdHealthGetRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	serverId   string
}

func (r MCPServersAPICheckMcpServerHealthV1McpServersServerIdHealthGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CheckMcpServerHealthV1McpServersServerIdHealthGetExecute(r)
}

/*
CheckMcpServerHealthV1McpServersServerIdHealthGet Check MCP server health status

Perform a health check on the specified MCP server by attempting to connect and retrieve available entities. Returns detailed status information and entity counts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPICheckMcpServerHealthV1McpServersServerIdHealthGetRequest
*/
func (a *MCPServersAPIService) CheckMcpServerHealthV1McpServersServerIdHealthGet(ctx context.Context, serverId string) MCPServersAPICheckMcpServerHealthV1McpServersServerIdHealthGetRequest {
	return MCPServersAPICheckMcpServerHealthV1McpServersServerIdHealthGetRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MCPServersAPIService) CheckMcpServerHealthV1McpServersServerIdHealthGetExecute(r MCPServersAPICheckMcpServerHealthV1McpServersServerIdHealthGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.CheckMcpServerHealthV1McpServersServerIdHealthGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}/health"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPICreateMcpServerV1McpServersPostRequest struct {
	ctx           context.Context
	ApiService    *MCPServersAPIService
	mCPServerBase *MCPServerBase
}

func (r MCPServersAPICreateMcpServerV1McpServersPostRequest) MCPServerBase(mCPServerBase MCPServerBase) MCPServersAPICreateMcpServerV1McpServersPostRequest {
	r.mCPServerBase = &mCPServerBase
	return r
}

func (r MCPServersAPICreateMcpServerV1McpServersPostRequest) Execute() (*MCPServerResponse, *http.Response, error) {
	return r.ApiService.CreateMcpServerV1McpServersPostExecute(r)
}

/*
CreateMcpServerV1McpServersPost Create a new MCP server

Create a new MCP (Model Context Protocol) server configuration. The server will be owned by the authenticated user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MCPServersAPICreateMcpServerV1McpServersPostRequest
*/
func (a *MCPServersAPIService) CreateMcpServerV1McpServersPost(ctx context.Context) MCPServersAPICreateMcpServerV1McpServersPostRequest {
	return MCPServersAPICreateMcpServerV1McpServersPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MCPServerResponse
func (a *MCPServersAPIService) CreateMcpServerV1McpServersPostExecute(r MCPServersAPICreateMcpServerV1McpServersPostRequest) (*MCPServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MCPServerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.CreateMcpServerV1McpServersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mCPServerBase == nil {
		return localVarReturnValue, nil, reportError("mCPServerBase is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mCPServerBase
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPIDeleteMcpServerV1McpServersServerIdDeleteRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	serverId   string
}

func (r MCPServersAPIDeleteMcpServerV1McpServersServerIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMcpServerV1McpServersServerIdDeleteExecute(r)
}

/*
DeleteMcpServerV1McpServersServerIdDelete Delete an MCP server

Permanently delete an MCP server configuration. Only the server owner can delete the server. The server cannot be deleted if it is currently being used by any capabilities.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPIDeleteMcpServerV1McpServersServerIdDeleteRequest
*/
func (a *MCPServersAPIService) DeleteMcpServerV1McpServersServerIdDelete(ctx context.Context, serverId string) MCPServersAPIDeleteMcpServerV1McpServersServerIdDeleteRequest {
	return MCPServersAPIDeleteMcpServerV1McpServersServerIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
func (a *MCPServersAPIService) DeleteMcpServerV1McpServersServerIdDeleteExecute(r MCPServersAPIDeleteMcpServerV1McpServersServerIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.DeleteMcpServerV1McpServersServerIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MCPServersAPIGetMcpServerEntitiesV1McpServersServerIdEntitiesGetRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	serverId   string
}

func (r MCPServersAPIGetMcpServerEntitiesV1McpServersServerIdEntitiesGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMcpServerEntitiesV1McpServersServerIdEntitiesGetExecute(r)
}

/*
GetMcpServerEntitiesV1McpServersServerIdEntitiesGet Get all entities from an MCP server

Retrieve all available entities (tools, resources, and prompts) from the specified MCP server. This includes function definitions, resource templates, and prompt templates.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPIGetMcpServerEntitiesV1McpServersServerIdEntitiesGetRequest
*/
func (a *MCPServersAPIService) GetMcpServerEntitiesV1McpServersServerIdEntitiesGet(ctx context.Context, serverId string) MCPServersAPIGetMcpServerEntitiesV1McpServersServerIdEntitiesGetRequest {
	return MCPServersAPIGetMcpServerEntitiesV1McpServersServerIdEntitiesGetRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *MCPServersAPIService) GetMcpServerEntitiesV1McpServersServerIdEntitiesGetExecute(r MCPServersAPIGetMcpServerEntitiesV1McpServersServerIdEntitiesGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.GetMcpServerEntitiesV1McpServersServerIdEntitiesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}/entities"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPIGetMcpServerPromptsV1McpServersServerIdPromptsGetRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	serverId   string
}

func (r MCPServersAPIGetMcpServerPromptsV1McpServersServerIdPromptsGetRequest) Execute() ([]*map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMcpServerPromptsV1McpServersServerIdPromptsGetExecute(r)
}

/*
GetMcpServerPromptsV1McpServersServerIdPromptsGet Get all prompts from an MCP server

Retrieve all available prompts and prompt templates from the specified MCP server. Prompts are reusable templates that can be used to generate consistent AI interactions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPIGetMcpServerPromptsV1McpServersServerIdPromptsGetRequest
*/
func (a *MCPServersAPIService) GetMcpServerPromptsV1McpServersServerIdPromptsGet(ctx context.Context, serverId string) MCPServersAPIGetMcpServerPromptsV1McpServersServerIdPromptsGetRequest {
	return MCPServersAPIGetMcpServerPromptsV1McpServersServerIdPromptsGetRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
//
//	@return []*map[string]interface{}
func (a *MCPServersAPIService) GetMcpServerPromptsV1McpServersServerIdPromptsGetExecute(r MCPServersAPIGetMcpServerPromptsV1McpServersServerIdPromptsGetRequest) ([]*map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []*map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.GetMcpServerPromptsV1McpServersServerIdPromptsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}/prompts"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPIGetMcpServerResourcesV1McpServersServerIdResourcesGetRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	serverId   string
}

func (r MCPServersAPIGetMcpServerResourcesV1McpServersServerIdResourcesGetRequest) Execute() ([]*map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMcpServerResourcesV1McpServersServerIdResourcesGetExecute(r)
}

/*
GetMcpServerResourcesV1McpServersServerIdResourcesGet Get all resources from an MCP server

Retrieve all available resources and resource templates from the specified MCP server. Resources provide access to external data sources, files, or APIs that capabilities can read from.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPIGetMcpServerResourcesV1McpServersServerIdResourcesGetRequest
*/
func (a *MCPServersAPIService) GetMcpServerResourcesV1McpServersServerIdResourcesGet(ctx context.Context, serverId string) MCPServersAPIGetMcpServerResourcesV1McpServersServerIdResourcesGetRequest {
	return MCPServersAPIGetMcpServerResourcesV1McpServersServerIdResourcesGetRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
//
//	@return []*map[string]interface{}
func (a *MCPServersAPIService) GetMcpServerResourcesV1McpServersServerIdResourcesGetExecute(r MCPServersAPIGetMcpServerResourcesV1McpServersServerIdResourcesGetRequest) ([]*map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []*map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.GetMcpServerResourcesV1McpServersServerIdResourcesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPIGetMcpServerToolsV1McpServersServerIdToolsGetRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	serverId   string
}

func (r MCPServersAPIGetMcpServerToolsV1McpServersServerIdToolsGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMcpServerToolsV1McpServersServerIdToolsGetExecute(r)
}

/*
GetMcpServerToolsV1McpServersServerIdToolsGet Get all tools from an MCP server

Retrieve all available tools (functions) from the specified MCP server. Tools are executable functions that can be called by capabilities to perform specific tasks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPIGetMcpServerToolsV1McpServersServerIdToolsGetRequest
*/
func (a *MCPServersAPIService) GetMcpServerToolsV1McpServersServerIdToolsGet(ctx context.Context, serverId string) MCPServersAPIGetMcpServerToolsV1McpServersServerIdToolsGetRequest {
	return MCPServersAPIGetMcpServerToolsV1McpServersServerIdToolsGetRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *MCPServersAPIService) GetMcpServerToolsV1McpServersServerIdToolsGetExecute(r MCPServersAPIGetMcpServerToolsV1McpServersServerIdToolsGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.GetMcpServerToolsV1McpServersServerIdToolsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}/tools"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPIGetMcpServerV1McpServersServerIdGetRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	serverId   string
}

func (r MCPServersAPIGetMcpServerV1McpServersServerIdGetRequest) Execute() (*MCPServerResponse, *http.Response, error) {
	return r.ApiService.GetMcpServerV1McpServersServerIdGetExecute(r)
}

/*
GetMcpServerV1McpServersServerIdGet Get MCP server by ID

Retrieve detailed information about a specific MCP server by its unique identifier. Only returns servers owned by the authenticated user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPIGetMcpServerV1McpServersServerIdGetRequest
*/
func (a *MCPServersAPIService) GetMcpServerV1McpServersServerIdGet(ctx context.Context, serverId string) MCPServersAPIGetMcpServerV1McpServersServerIdGetRequest {
	return MCPServersAPIGetMcpServerV1McpServersServerIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
//
//	@return MCPServerResponse
func (a *MCPServersAPIService) GetMcpServerV1McpServersServerIdGetExecute(r MCPServersAPIGetMcpServerV1McpServersServerIdGetRequest) (*MCPServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MCPServerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.GetMcpServerV1McpServersServerIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPIListMcpServersV1McpServersGetRequest struct {
	ctx        context.Context
	ApiService *MCPServersAPIService
	page       *int32
	size       *int32
	sort       *string
	filter     *string
}

func (r MCPServersAPIListMcpServersV1McpServersGetRequest) Page(page int32) MCPServersAPIListMcpServersV1McpServersGetRequest {
	r.page = &page
	return r
}

func (r MCPServersAPIListMcpServersV1McpServersGetRequest) Size(size int32) MCPServersAPIListMcpServersV1McpServersGetRequest {
	r.size = &size
	return r
}

func (r MCPServersAPIListMcpServersV1McpServersGetRequest) Sort(sort string) MCPServersAPIListMcpServersV1McpServersGetRequest {
	r.sort = &sort
	return r
}

func (r MCPServersAPIListMcpServersV1McpServersGetRequest) Filter(filter string) MCPServersAPIListMcpServersV1McpServersGetRequest {
	r.filter = &filter
	return r
}

func (r MCPServersAPIListMcpServersV1McpServersGetRequest) Execute() (*PagedResponseModelMCPServerResponse, *http.Response, error) {
	return r.ApiService.ListMcpServersV1McpServersGetExecute(r)
}

/*
ListMcpServersV1McpServersGet List MCP servers

Retrieve a paginated list of all MCP (Model Context Protocol) servers owned by the current user. Supports sorting and filtering through pagination parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return MCPServersAPIListMcpServersV1McpServersGetRequest
*/
func (a *MCPServersAPIService) ListMcpServersV1McpServersGet(ctx context.Context) MCPServersAPIListMcpServersV1McpServersGetRequest {
	return MCPServersAPIListMcpServersV1McpServersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PagedResponseModelMCPServerResponse
func (a *MCPServersAPIService) ListMcpServersV1McpServersGetExecute(r MCPServersAPIListMcpServersV1McpServersGetRequest) (*PagedResponseModelMCPServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResponseModelMCPServerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.ListMcpServersV1McpServersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", defaultValue, "form", "")
		r.size = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", defaultValue, "form", "")
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest struct {
	ctx           context.Context
	ApiService    *MCPServersAPIService
	serverId      string
	mCPServerBase *MCPServerBase
}

func (r MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest) MCPServerBase(mCPServerBase MCPServerBase) MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest {
	r.mCPServerBase = &mCPServerBase
	return r
}

func (r MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest) Execute() (*MCPServerResponse, *http.Response, error) {
	return r.ApiService.UpdateMcpServerV1McpServersServerIdPutExecute(r)
}

/*
UpdateMcpServerV1McpServersServerIdPut Update an existing MCP server

Update the configuration of an existing MCP server. Only the server owner can update the configuration.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serverId
	@return MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest
*/
func (a *MCPServersAPIService) UpdateMcpServerV1McpServersServerIdPut(ctx context.Context, serverId string) MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest {
	return MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		serverId:   serverId,
	}
}

// Execute executes the request
//
//	@return MCPServerResponse
func (a *MCPServersAPIService) UpdateMcpServerV1McpServersServerIdPutExecute(r MCPServersAPIUpdateMcpServerV1McpServersServerIdPutRequest) (*MCPServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MCPServerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MCPServersAPIService.UpdateMcpServerV1McpServersServerIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mcp-servers/{server_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"server_id"+"}", url.PathEscape(parameterValueToString(r.serverId, "serverId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mCPServerBase == nil {
		return localVarReturnValue, nil, reportError("mCPServerBase is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mCPServerBase
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
