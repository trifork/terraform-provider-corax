/*
Corax API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.91.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// KnowledgeCollectionsAPIService KnowledgeCollectionsAPI service
type KnowledgeCollectionsAPIService service

type KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest struct {
	ctx              context.Context
	ApiService       *KnowledgeCollectionsAPIService
	collectionCreate *CollectionCreate
}

func (r KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest) CollectionCreate(collectionCreate CollectionCreate) KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest {
	r.collectionCreate = &collectionCreate
	return r
}

func (r KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest) Execute() (*Collection, *http.Response, error) {
	return r.ApiService.CreateCollectionAsyncV1CollectionsPostExecute(r)
}

/*
CreateCollectionAsyncV1CollectionsPost Create Collection Async

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest
*/
func (a *KnowledgeCollectionsAPIService) CreateCollectionAsyncV1CollectionsPost(ctx context.Context) KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest {
	return KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Collection
func (a *KnowledgeCollectionsAPIService) CreateCollectionAsyncV1CollectionsPostExecute(r KnowledgeCollectionsAPICreateCollectionAsyncV1CollectionsPostRequest) (*Collection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Collection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.CreateCollectionAsyncV1CollectionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.collectionCreate == nil {
		return localVarReturnValue, nil, reportError("collectionCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.collectionCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KnowledgeCollectionsAPIDeleteCollectionV1CollectionsCollectionIdDeleteRequest struct {
	ctx          context.Context
	ApiService   *KnowledgeCollectionsAPIService
	collectionId string
}

func (r KnowledgeCollectionsAPIDeleteCollectionV1CollectionsCollectionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCollectionV1CollectionsCollectionIdDeleteExecute(r)
}

/*
DeleteCollectionV1CollectionsCollectionIdDelete Delete Collection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionId
	@return KnowledgeCollectionsAPIDeleteCollectionV1CollectionsCollectionIdDeleteRequest
*/
func (a *KnowledgeCollectionsAPIService) DeleteCollectionV1CollectionsCollectionIdDelete(ctx context.Context, collectionId string) KnowledgeCollectionsAPIDeleteCollectionV1CollectionsCollectionIdDeleteRequest {
	return KnowledgeCollectionsAPIDeleteCollectionV1CollectionsCollectionIdDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
func (a *KnowledgeCollectionsAPIService) DeleteCollectionV1CollectionsCollectionIdDeleteExecute(r KnowledgeCollectionsAPIDeleteCollectionV1CollectionsCollectionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.DeleteCollectionV1CollectionsCollectionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collection_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KnowledgeCollectionsAPIDeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteRequest struct {
	ctx          context.Context
	ApiService   *KnowledgeCollectionsAPIService
	collectionId string
	documentId   string
}

func (r KnowledgeCollectionsAPIDeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteExecute(r)
}

/*
DeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDelete Delete Document

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionId
	@param documentId
	@return KnowledgeCollectionsAPIDeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteRequest
*/
func (a *KnowledgeCollectionsAPIService) DeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDelete(ctx context.Context, collectionId string, documentId string) KnowledgeCollectionsAPIDeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteRequest {
	return KnowledgeCollectionsAPIDeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
		documentId:   documentId,
	}
}

// Execute executes the request
func (a *KnowledgeCollectionsAPIService) DeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteExecute(r KnowledgeCollectionsAPIDeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.DeleteDocumentV1CollectionsCollectionIdDocumentsDocumentIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collection_id}/documents/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest struct {
	ctx          context.Context
	ApiService   *KnowledgeCollectionsAPIService
	collectionId string
	files        []*os.File
}

func (r KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest) Files(files []*os.File) KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest {
	r.files = files
	return r
}

func (r KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest) Execute() (*DocumentEmbeddingResponse, *http.Response, error) {
	return r.ApiService.EmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostExecute(r)
}

/*
EmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPost Embed Documents To Collection Async

Embed multiple documents to a specific collection asynchronously with HATEOAS links.

Args:

	request (Request): The FastAPI request object for building HATEOAS links.
	collection_id (uuid.UUID): The ID of the collection to embed documents to.
	files (List[UploadFile]): A list of files to be embedded.
	service (AsyncCollectionService): The collection service.
	user (User): The current authenticated user.

Returns:

	DocumentEmbeddingResponse: A response with HATEOAS links and embedding status.

Raises:

	   HTTPException: If the collection is not found or if there's an error during embedding.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionId
	@return KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest
*/
func (a *KnowledgeCollectionsAPIService) EmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPost(ctx context.Context, collectionId string) KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest {
	return KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//
//	@return DocumentEmbeddingResponse
func (a *KnowledgeCollectionsAPIService) EmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostExecute(r KnowledgeCollectionsAPIEmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPostRequest) (*DocumentEmbeddingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DocumentEmbeddingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.EmbedDocumentsToCollectionAsyncV1CollectionsCollectionIdEmbedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collection_id}/embed"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.files == nil {
		return localVarReturnValue, nil, reportError("files is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var filesLocalVarFormFileName string
	var filesLocalVarFileName string
	var filesLocalVarFileBytes []byte

	filesLocalVarFormFileName = "files"
	filesLocalVarFile := r.files

	if filesLocalVarFile != nil {
		// loop through the array to prepare multiple files upload
		for _, filesLocalVarFileValue := range filesLocalVarFile {
			fbs, _ := io.ReadAll(filesLocalVarFileValue)

			filesLocalVarFileBytes = fbs
			filesLocalVarFileName = filesLocalVarFileValue.Name()
			filesLocalVarFileValue.Close()
			formFiles = append(formFiles, formFile{fileBytes: filesLocalVarFileBytes, fileName: filesLocalVarFileName, formFileName: filesLocalVarFormFileName})
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KnowledgeCollectionsAPIReadCollectionAsyncV1CollectionsCollectionIdGetRequest struct {
	ctx          context.Context
	ApiService   *KnowledgeCollectionsAPIService
	collectionId string
}

func (r KnowledgeCollectionsAPIReadCollectionAsyncV1CollectionsCollectionIdGetRequest) Execute() (*Collection, *http.Response, error) {
	return r.ApiService.ReadCollectionAsyncV1CollectionsCollectionIdGetExecute(r)
}

/*
ReadCollectionAsyncV1CollectionsCollectionIdGet Read Collection Async

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionId
	@return KnowledgeCollectionsAPIReadCollectionAsyncV1CollectionsCollectionIdGetRequest
*/
func (a *KnowledgeCollectionsAPIService) ReadCollectionAsyncV1CollectionsCollectionIdGet(ctx context.Context, collectionId string) KnowledgeCollectionsAPIReadCollectionAsyncV1CollectionsCollectionIdGetRequest {
	return KnowledgeCollectionsAPIReadCollectionAsyncV1CollectionsCollectionIdGetRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//
//	@return Collection
func (a *KnowledgeCollectionsAPIService) ReadCollectionAsyncV1CollectionsCollectionIdGetExecute(r KnowledgeCollectionsAPIReadCollectionAsyncV1CollectionsCollectionIdGetRequest) (*Collection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Collection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.ReadCollectionAsyncV1CollectionsCollectionIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collection_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest struct {
	ctx          context.Context
	ApiService   *KnowledgeCollectionsAPIService
	collectionId string
	page         *int32
	size         *int32
	sort         *string
	filter       *string
}

func (r KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest) Page(page int32) KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest {
	r.page = &page
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest) Size(size int32) KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest {
	r.size = &size
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest) Sort(sort string) KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest {
	r.sort = &sort
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest) Filter(filter string) KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest {
	r.filter = &filter
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest) Execute() (*PagedResponseModelDocument, *http.Response, error) {
	return r.ApiService.ReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetExecute(r)
}

/*
ReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGet Read Collection Documents Async

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionId
	@return KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest
*/
func (a *KnowledgeCollectionsAPIService) ReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGet(ctx context.Context, collectionId string) KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest {
	return KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//
//	@return PagedResponseModelDocument
func (a *KnowledgeCollectionsAPIService) ReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetExecute(r KnowledgeCollectionsAPIReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGetRequest) (*PagedResponseModelDocument, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResponseModelDocument
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.ReadCollectionDocumentsAsyncV1CollectionsCollectionIdDocumentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collection_id}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", defaultValue, "form", "")
		r.size = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", defaultValue, "form", "")
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest struct {
	ctx        context.Context
	ApiService *KnowledgeCollectionsAPIService
	page       *int32
	size       *int32
	sort       *string
	filter     *string
}

func (r KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest) Page(page int32) KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest {
	r.page = &page
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest) Size(size int32) KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest {
	r.size = &size
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest) Sort(sort string) KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest {
	r.sort = &sort
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest) Filter(filter string) KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest {
	r.filter = &filter
	return r
}

func (r KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest) Execute() (*PagedResponseModelCollection, *http.Response, error) {
	return r.ApiService.ReadCollectionsAsyncV1CollectionsGetExecute(r)
}

/*
ReadCollectionsAsyncV1CollectionsGet Read Collections Async

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest
*/
func (a *KnowledgeCollectionsAPIService) ReadCollectionsAsyncV1CollectionsGet(ctx context.Context) KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest {
	return KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PagedResponseModelCollection
func (a *KnowledgeCollectionsAPIService) ReadCollectionsAsyncV1CollectionsGetExecute(r KnowledgeCollectionsAPIReadCollectionsAsyncV1CollectionsGetRequest) (*PagedResponseModelCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResponseModelCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.ReadCollectionsAsyncV1CollectionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", defaultValue, "form", "")
		r.size = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", defaultValue, "form", "")
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest struct {
	ctx              context.Context
	ApiService       *KnowledgeCollectionsAPIService
	collectionId     string
	collectionUpdate *CollectionUpdate
}

func (r KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest) CollectionUpdate(collectionUpdate CollectionUpdate) KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest {
	r.collectionUpdate = &collectionUpdate
	return r
}

func (r KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest) Execute() (*Collection, *http.Response, error) {
	return r.ApiService.UpdateCollectionAsyncV1CollectionsCollectionIdPutExecute(r)
}

/*
UpdateCollectionAsyncV1CollectionsCollectionIdPut Update Collection Async

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param collectionId
	@return KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest
*/
func (a *KnowledgeCollectionsAPIService) UpdateCollectionAsyncV1CollectionsCollectionIdPut(ctx context.Context, collectionId string) KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest {
	return KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest{
		ApiService:   a,
		ctx:          ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//
//	@return Collection
func (a *KnowledgeCollectionsAPIService) UpdateCollectionAsyncV1CollectionsCollectionIdPutExecute(r KnowledgeCollectionsAPIUpdateCollectionAsyncV1CollectionsCollectionIdPutRequest) (*Collection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Collection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KnowledgeCollectionsAPIService.UpdateCollectionAsyncV1CollectionsCollectionIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collection_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"collection_id"+"}", url.PathEscape(parameterValueToString(r.collectionId, "collectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.collectionUpdate == nil {
		return localVarReturnValue, nil, reportError("collectionUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.collectionUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
