/*
Corax API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.91.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CapabilitiesAPIService CapabilitiesAPI service
type CapabilitiesAPIService service

type CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest struct {
	ctx         context.Context
	ApiService  *CapabilitiesAPIService
	capability1 *Capability1
}

func (r CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest) Capability1(capability1 Capability1) CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest {
	r.capability1 = &capability1
	return r
}

func (r CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest) Execute() (*ResponseCreateCapabilityV1CapabilitiesPost, *http.Response, error) {
	return r.ApiService.CreateCapabilityV1CapabilitiesPostExecute(r)
}

/*
CreateCapabilityV1CapabilitiesPost Create Capability

Create a new capability

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest
*/
func (a *CapabilitiesAPIService) CreateCapabilityV1CapabilitiesPost(ctx context.Context) CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest {
	return CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ResponseCreateCapabilityV1CapabilitiesPost
func (a *CapabilitiesAPIService) CreateCapabilityV1CapabilitiesPostExecute(r CapabilitiesAPICreateCapabilityV1CapabilitiesPostRequest) (*ResponseCreateCapabilityV1CapabilitiesPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseCreateCapabilityV1CapabilitiesPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.CreateCapabilityV1CapabilitiesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.capability1 == nil {
		return localVarReturnValue, nil, reportError("capability1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.capability1
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIDeleteCapabilityV1CapabilitiesCapabilityIdDeleteRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	capabilityId CapabilityId1
}

func (r CapabilitiesAPIDeleteCapabilityV1CapabilitiesCapabilityIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCapabilityV1CapabilitiesCapabilityIdDeleteExecute(r)
}

/*
DeleteCapabilityV1CapabilitiesCapabilityIdDelete Delete Capability

Delete a capability

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIDeleteCapabilityV1CapabilitiesCapabilityIdDeleteRequest
*/
func (a *CapabilitiesAPIService) DeleteCapabilityV1CapabilitiesCapabilityIdDelete(ctx context.Context, capabilityId CapabilityId1) CapabilitiesAPIDeleteCapabilityV1CapabilitiesCapabilityIdDeleteRequest {
	return CapabilitiesAPIDeleteCapabilityV1CapabilitiesCapabilityIdDeleteRequest{
		ApiService:   a,
		ctx:          ctx,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
func (a *CapabilitiesAPIService) DeleteCapabilityV1CapabilitiesCapabilityIdDeleteExecute(r CapabilitiesAPIDeleteCapabilityV1CapabilitiesCapabilityIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.DeleteCapabilityV1CapabilitiesCapabilityIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest struct {
	ctx             context.Context
	ApiService      *CapabilitiesAPIService
	capabilityId    CapabilityId1
	executionCreate *ExecutionCreate
	stream          *bool
	streamTransport *StreamingTransport
}

func (r CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest) ExecutionCreate(executionCreate ExecutionCreate) CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest {
	r.executionCreate = &executionCreate
	return r
}

// Stream incremental chat capability responses.
func (r CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest) Stream(stream bool) CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest {
	r.stream = &stream
	return r
}

// Output transport when streaming. Use &#39;streamablehttp&#39; for newline-delimited JSON chunks or &#39;sse&#39; for legacy Server-Sent Events.
func (r CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest) StreamTransport(streamTransport StreamingTransport) CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest {
	r.streamTransport = &streamTransport
	return r
}

func (r CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.ExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostExecute(r)
}

/*
ExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPost Execute Capability

Execute a capability with type-specific payload format

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest
*/
func (a *CapabilitiesAPIService) ExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPost(ctx context.Context, capabilityId CapabilityId1) CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest {
	return CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest{
		ApiService:   a,
		ctx:          ctx,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *CapabilitiesAPIService) ExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostExecute(r CapabilitiesAPIExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPostRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.ExecuteCapabilityV1CapabilitiesCapabilityIdExecutionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executionCreate == nil {
		return localVarReturnValue, nil, reportError("executionCreate is required and must be specified")
	}

	if r.stream != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream", r.stream, "form", "")
	} else {
		var defaultValue bool = false
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream", defaultValue, "form", "")
		r.stream = &defaultValue
	}
	if r.streamTransport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_transport", r.streamTransport, "form", "")
	} else {
		var defaultValue StreamingTransport = "streamablehttp"
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream_transport", defaultValue, "form", "")
		r.streamTransport = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIGetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	version      int32
	capabilityId CapabilityId1
}

func (r CapabilitiesAPIGetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetRequest) Execute() (*CapabilityRepresentation, *http.Response, error) {
	return r.ApiService.GetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetExecute(r)
}

/*
GetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGet Get Capability Version

Get a specific version of a capability

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param version
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIGetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetRequest
*/
func (a *CapabilitiesAPIService) GetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGet(ctx context.Context, version int32, capabilityId CapabilityId1) CapabilitiesAPIGetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetRequest {
	return CapabilitiesAPIGetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetRequest{
		ApiService:   a,
		ctx:          ctx,
		version:      version,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return CapabilityRepresentation
func (a *CapabilitiesAPIService) GetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetExecute(r CapabilitiesAPIGetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGetRequest) (*CapabilityRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CapabilityRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.GetCapabilityVersionV1CapabilitiesCapabilityIdVersionsVersionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIGetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	executionId  string
	capabilityId CapabilityId1
}

func (r CapabilitiesAPIGetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetRequest) Execute() (*ExecutionResult, *http.Response, error) {
	return r.ApiService.GetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetExecute(r)
}

/*
GetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGet Get Execution Result

Get a capability execution result

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIGetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetRequest
*/
func (a *CapabilitiesAPIService) GetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGet(ctx context.Context, executionId string, capabilityId CapabilityId1) CapabilitiesAPIGetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetRequest {
	return CapabilitiesAPIGetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetRequest{
		ApiService:   a,
		ctx:          ctx,
		executionId:  executionId,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return ExecutionResult
func (a *CapabilitiesAPIService) GetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetExecute(r CapabilitiesAPIGetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGetRequest) (*ExecutionResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.GetExecutionResultV1CapabilitiesCapabilityIdExecutionsExecutionIdResultGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/executions/{execution_id}/result"
	localVarPath = strings.Replace(localVarPath, "{"+"execution_id"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIGetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	executionId  string
	capabilityId CapabilityId1
}

func (r CapabilitiesAPIGetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetRequest) Execute() (*ExecutionUsage, *http.Response, error) {
	return r.ApiService.GetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetExecute(r)
}

/*
GetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGet Get Execution Usage

Get a capability execution usage

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIGetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetRequest
*/
func (a *CapabilitiesAPIService) GetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGet(ctx context.Context, executionId string, capabilityId CapabilityId1) CapabilitiesAPIGetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetRequest {
	return CapabilitiesAPIGetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetRequest{
		ApiService:   a,
		ctx:          ctx,
		executionId:  executionId,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return ExecutionUsage
func (a *CapabilitiesAPIService) GetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetExecute(r CapabilitiesAPIGetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGetRequest) (*ExecutionUsage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionUsage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.GetExecutionUsageV1CapabilitiesCapabilityIdExecutionsExecutionIdUsageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/executions/{execution_id}/usage"
	localVarPath = strings.Replace(localVarPath, "{"+"execution_id"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIGetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	executionId  string
	capabilityId CapabilityId1
}

func (r CapabilitiesAPIGetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetRequest) Execute() (*Execution, *http.Response, error) {
	return r.ApiService.GetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetExecute(r)
}

/*
GetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGet Get Execution

Get a capability execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIGetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetRequest
*/
func (a *CapabilitiesAPIService) GetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGet(ctx context.Context, executionId string, capabilityId CapabilityId1) CapabilitiesAPIGetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetRequest {
	return CapabilitiesAPIGetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetRequest{
		ApiService:   a,
		ctx:          ctx,
		executionId:  executionId,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return Execution
func (a *CapabilitiesAPIService) GetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetExecute(r CapabilitiesAPIGetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGetRequest) (*Execution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Execution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.GetExecutionV1CapabilitiesCapabilityIdExecutionsExecutionIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/executions/{execution_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"execution_id"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest struct {
	ctx        context.Context
	ApiService *CapabilitiesAPIService
	page       *int32
	size       *int32
	sort       *string
	filter     *string
}

func (r CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest) Page(page int32) CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest {
	r.page = &page
	return r
}

func (r CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest) Size(size int32) CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest {
	r.size = &size
	return r
}

func (r CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest) Sort(sort string) CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest {
	r.sort = &sort
	return r
}

func (r CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest) Filter(filter string) CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest {
	r.filter = &filter
	return r
}

func (r CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest) Execute() (*PagedResponseModelCapability, *http.Response, error) {
	return r.ApiService.ListCapabilitiesV1CapabilitiesGetExecute(r)
}

/*
ListCapabilitiesV1CapabilitiesGet List Capabilities

List all capabilities

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest
*/
func (a *CapabilitiesAPIService) ListCapabilitiesV1CapabilitiesGet(ctx context.Context) CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest {
	return CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PagedResponseModelCapability
func (a *CapabilitiesAPIService) ListCapabilitiesV1CapabilitiesGetExecute(r CapabilitiesAPIListCapabilitiesV1CapabilitiesGetRequest) (*PagedResponseModelCapability, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResponseModelCapability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.ListCapabilitiesV1CapabilitiesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", defaultValue, "form", "")
		r.size = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", defaultValue, "form", "")
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	capabilityId CapabilityId1
	page         *int32
	size         *int32
	sort         *string
	filter       *string
}

func (r CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest) Page(page int32) CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest {
	r.page = &page
	return r
}

func (r CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest) Size(size int32) CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest {
	r.size = &size
	return r
}

func (r CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest) Sort(sort string) CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest {
	r.sort = &sort
	return r
}

func (r CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest) Filter(filter string) CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest {
	r.filter = &filter
	return r
}

func (r CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest) Execute() (*PagedResponseModelCapabilityVersion, *http.Response, error) {
	return r.ApiService.ListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetExecute(r)
}

/*
ListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGet List Capability Versions

List all versions of a capability

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest
*/
func (a *CapabilitiesAPIService) ListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGet(ctx context.Context, capabilityId CapabilityId1) CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest {
	return CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest{
		ApiService:   a,
		ctx:          ctx,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return PagedResponseModelCapabilityVersion
func (a *CapabilitiesAPIService) ListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetExecute(r CapabilitiesAPIListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGetRequest) (*PagedResponseModelCapabilityVersion, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResponseModelCapabilityVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.ListCapabilityVersionsV1CapabilitiesCapabilityIdVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", defaultValue, "form", "")
		r.size = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", defaultValue, "form", "")
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	capabilityId CapabilityId1
	page         *int32
	size         *int32
	sort         *string
	filter       *string
}

func (r CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest) Page(page int32) CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest {
	r.page = &page
	return r
}

func (r CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest) Size(size int32) CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest {
	r.size = &size
	return r
}

func (r CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest) Sort(sort string) CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest {
	r.sort = &sort
	return r
}

func (r CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest) Filter(filter string) CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest {
	r.filter = &filter
	return r
}

func (r CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest) Execute() (*PagedResponseModelExecution, *http.Response, error) {
	return r.ApiService.ListExecutionsV1CapabilitiesCapabilityIdExecutionsGetExecute(r)
}

/*
ListExecutionsV1CapabilitiesCapabilityIdExecutionsGet List Executions

List all capability executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest
*/
func (a *CapabilitiesAPIService) ListExecutionsV1CapabilitiesCapabilityIdExecutionsGet(ctx context.Context, capabilityId CapabilityId1) CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest {
	return CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest{
		ApiService:   a,
		ctx:          ctx,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return PagedResponseModelExecution
func (a *CapabilitiesAPIService) ListExecutionsV1CapabilitiesCapabilityIdExecutionsGetExecute(r CapabilitiesAPIListExecutionsV1CapabilitiesCapabilityIdExecutionsGetRequest) (*PagedResponseModelExecution, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PagedResponseModelExecution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.ListExecutionsV1CapabilitiesCapabilityIdExecutionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", defaultValue, "form", "")
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	} else {
		var defaultValue int32 = 10
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", defaultValue, "form", "")
		r.size = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "id"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", defaultValue, "form", "")
		r.sort = &defaultValue
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest struct {
	ctx            context.Context
	ApiService     *CapabilitiesAPIService
	executionId    string
	capabilityId   CapabilityId1
	feedbackCreate *FeedbackCreate
}

func (r CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest) FeedbackCreate(feedbackCreate FeedbackCreate) CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest {
	r.feedbackCreate = &feedbackCreate
	return r
}

func (r CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest) Execute() (*ExecutionResult, *http.Response, error) {
	return r.ApiService.ProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostExecute(r)
}

/*
ProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPost Provide Feedback

Provide feedback for a capability execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest
*/
func (a *CapabilitiesAPIService) ProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPost(ctx context.Context, executionId string, capabilityId CapabilityId1) CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest {
	return CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest{
		ApiService:   a,
		ctx:          ctx,
		executionId:  executionId,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return ExecutionResult
func (a *CapabilitiesAPIService) ProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostExecute(r CapabilitiesAPIProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPostRequest) (*ExecutionResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExecutionResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.ProvideFeedbackV1CapabilitiesCapabilityIdExecutionsExecutionIdFeedbackPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/executions/{execution_id}/feedback"
	localVarPath = strings.Replace(localVarPath, "{"+"execution_id"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.feedbackCreate == nil {
		return localVarReturnValue, nil, reportError("feedbackCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.feedbackCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIReadCapabilityV1CapabilitiesCapabilityIdGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	capabilityId CapabilityId
}

func (r CapabilitiesAPIReadCapabilityV1CapabilitiesCapabilityIdGetRequest) Execute() (*CapabilityRepresentation, *http.Response, error) {
	return r.ApiService.ReadCapabilityV1CapabilitiesCapabilityIdGetExecute(r)
}

/*
ReadCapabilityV1CapabilitiesCapabilityIdGet Read Capability

Get a single capability

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIReadCapabilityV1CapabilitiesCapabilityIdGetRequest
*/
func (a *CapabilitiesAPIService) ReadCapabilityV1CapabilitiesCapabilityIdGet(ctx context.Context, capabilityId CapabilityId) CapabilitiesAPIReadCapabilityV1CapabilitiesCapabilityIdGetRequest {
	return CapabilitiesAPIReadCapabilityV1CapabilitiesCapabilityIdGetRequest{
		ApiService:   a,
		ctx:          ctx,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return CapabilityRepresentation
func (a *CapabilitiesAPIService) ReadCapabilityV1CapabilitiesCapabilityIdGetExecute(r CapabilitiesAPIReadCapabilityV1CapabilitiesCapabilityIdGetRequest) (*CapabilityRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CapabilityRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.ReadCapabilityV1CapabilitiesCapabilityIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest struct {
	ctx                                context.Context
	ApiService                         *CapabilitiesAPIService
	capabilityId                       CapabilityId1
	capabilitySetDefaultVersionRequest *CapabilitySetDefaultVersionRequest
}

func (r CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest) CapabilitySetDefaultVersionRequest(capabilitySetDefaultVersionRequest CapabilitySetDefaultVersionRequest) CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest {
	r.capabilitySetDefaultVersionRequest = &capabilitySetDefaultVersionRequest
	return r
}

func (r CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest) Execute() (*CapabilityRepresentation, *http.Response, error) {
	return r.ApiService.SetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutExecute(r)
}

/*
SetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPut Set Default Capability Version

Set a capability version as the default version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest
*/
func (a *CapabilitiesAPIService) SetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPut(ctx context.Context, capabilityId CapabilityId1) CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest {
	return CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest{
		ApiService:   a,
		ctx:          ctx,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return CapabilityRepresentation
func (a *CapabilitiesAPIService) SetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutExecute(r CapabilitiesAPISetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPutRequest) (*CapabilityRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CapabilityRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.SetDefaultCapabilityVersionV1CapabilitiesCapabilityIdDefaultVersionPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/default-version"
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.capabilitySetDefaultVersionRequest == nil {
		return localVarReturnValue, nil, reportError("capabilitySetDefaultVersionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.capabilitySetDefaultVersionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	executionId  string
	capabilityId CapabilityId1
	transport    *StreamingTransport
}

// Preferred streaming transport. Use &#39;streamablehttp&#39; for newline-delimited JSON chunks or &#39;sse&#39; for Server-Sent Events.
func (r CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest) Transport(transport StreamingTransport) CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest {
	r.transport = &transport
	return r
}

func (r CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.StreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetExecute(r)
}

/*
StreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGet Stream Execution Events

Stream incremental updates for a capability execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param executionId
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest
*/
func (a *CapabilitiesAPIService) StreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGet(ctx context.Context, executionId string, capabilityId CapabilityId1) CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest {
	return CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest{
		ApiService:   a,
		ctx:          ctx,
		executionId:  executionId,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *CapabilitiesAPIService) StreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetExecute(r CapabilitiesAPIStreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.StreamExecutionEventsV1CapabilitiesCapabilityIdExecutionsExecutionIdStreamGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}/executions/{execution_id}/stream"
	localVarPath = strings.Replace(localVarPath, "{"+"execution_id"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transport != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transport", r.transport, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest struct {
	ctx          context.Context
	ApiService   *CapabilitiesAPIService
	capabilityId CapabilityId1
	capability2  *Capability2
}

func (r CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest) Capability2(capability2 Capability2) CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest {
	r.capability2 = &capability2
	return r
}

func (r CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest) Execute() (*CapabilityRepresentation, *http.Response, error) {
	return r.ApiService.UpdateCapabilityV1CapabilitiesCapabilityIdPutExecute(r)
}

/*
UpdateCapabilityV1CapabilitiesCapabilityIdPut Update Capability

Update a capability

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param capabilityId The ID or semantic ID of the capability
	@return CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest
*/
func (a *CapabilitiesAPIService) UpdateCapabilityV1CapabilitiesCapabilityIdPut(ctx context.Context, capabilityId CapabilityId1) CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest {
	return CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest{
		ApiService:   a,
		ctx:          ctx,
		capabilityId: capabilityId,
	}
}

// Execute executes the request
//
//	@return CapabilityRepresentation
func (a *CapabilitiesAPIService) UpdateCapabilityV1CapabilitiesCapabilityIdPutExecute(r CapabilitiesAPIUpdateCapabilityV1CapabilitiesCapabilityIdPutRequest) (*CapabilityRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CapabilityRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapabilitiesAPIService.UpdateCapabilityV1CapabilitiesCapabilityIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/capabilities/{capability_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"capability_id"+"}", url.PathEscape(parameterValueToString(r.capabilityId, "capabilityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.capability2 == nil {
		return localVarReturnValue, nil, reportError("capability2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.capability2
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
